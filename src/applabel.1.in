'\" t
.\" Automatically generated by Pandoc 2.19.2
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "applabel" "1" "" "YAF Application Labeling" "YAF ??PACKAGE_VERSION??"
.hy
.SH NAME
.PP
applabel - YAF Application Labeling
.SH SYNOPSIS
.IP
.nf
\f[C]
yaf ... --applabel --max-payload=PAYLOAD [--dpi-rules-file=FILE]
\f[R]
.fi
.SH DESCRIPTION
.PP
\f[B]yaf\f[R] can examine packet payloads to determine the application protocol
in use within a flow and export a 16-bit application label with each flow.
The exported application label (applabel) uses the primary well-known port
number for the protocol.
In most cases, the applabel is the official Internet Assigned Numbers Authority
(IANA)-assigned port number, but in some cases the applabel may be the de facto
port for the protocol or a custom label when a protocol does not have any
well-known ports or overlaps with another applabel.
For example, HTTP traffic, independent of what port the traffic is detected on,
will be labeled with a value of 80, the default HTTP port.
.PP
The applabel is exported to the \f[B]silkAppLabel\f[R] CERT (PEN 6871)
Information Element (IE) 33.
.PP
Labels and rules are taken from a configuration file read by \f[B]yaf\f[R] at
startup time.
Since the application labeling and Deep Packet Inspection (DPI) rules are, as of
YAF 3, combined in a single Lua confguration file, the rule file can be given on
the command line with the \f[B]--dpi-rules-file\f[R] option or \f[B]yaf\f[R]
will try to read it from the default location of
\f[V]/usr/local/etc/yafDPIRules.conf.\f[R] (The location may be different
depending on how your \f[B]yaf\f[R] installation was built.)
.RS
.PP
\f[B]Note:\f[R] The application labeling support in YAF 3 differs greatly from
that in prior releases.
If using a previous release of \f[B]yaf\f[R], please consult the manual pages
for your installation.
.RE
.SS Required build time options: --enable-applabel
.PP
Application labeling is not included in \f[B]yaf\f[R] by default; the
\f[B]--enable-applabel\f[R] option must be passed to \f[V]configure\f[R].
.PP
To check whether your \f[B]yaf\f[R] installation has application labeling
enabled, run \f[B]yaf\f[R] \f[B]--version\f[R] and check the setting of
\[dq]Application Labeling\[dq].
.SS Minimum required run time options: --applabel --max-payload
.PP
Application labeling always requires payload capture to be enabled with the
\f[B]--max-payload\f[R] option.
.PP
Application labeling is generally a \[dq]lighter\[dq] inspection of the packet
payloads than deep packet inspection (DPI).
A minimum payload capture length of 384 bytes is recommended for best results if
using application labeling without DPI enabled, in which case only the
\f[B]--applabel\f[R] option is required:
.IP
.nf
\f[C]
yaf --daemonize --live pcap --in eth0               \[rs]
    --out localhost --ipfix-port=18000 --ipfix tcp  \[rs]
    --applabel --max-payload=384
\f[R]
.fi
.PP
Running \f[B]yaf\f[R] with application labeling, no DPI, and specifying a rules
file:
.IP
.nf
\f[C]
yaf --daemonize --live pcap --in eth0               \[rs]
    --out localhost --ipfix-port=18000 --ipfix tcp  \[rs]
    --applabel --max-payload=384 --dpi-rules-file=*FILE*
\f[R]
.fi
.PP
If DPI is to be exported, this implies the use of application labeling and only
the \f[B]--dpi\f[R] option is required, which will enable both features.
When DPI is enabled, a minimum payload capture length of 2048 bytes is
recommended, but 4096 bytes is ideal for best results (including capture of full
certificate chains):
.IP
.nf
\f[C]
yaf --daemonize --live pcap --in eth0               \[rs]
    --out localhost --ipfix-port=18000 --ipfix tcp  \[rs]
    --dpi --max-payload=4096
\f[R]
.fi
.SS Configuration File
.PP
While both applabel and DPI-related configuration options are in the
configuration file, here we are focusing only on options relevant to application
labeling.
.SS Format
.PP
The configuration file is written in Lua (https://www.lua.org/).
For specifics of the Lua language, see
<http://www.lua.org/manual/5.3/manual.html>
.PP
Comments in Lua start with double hyphens (\f[V]--\f[R]) and continue to the end
of the line.
.PP
The file must define a variable named \f[V]applabels\f[R] which is an array of
applabel tables.
Each applabel table defines a rule that tells \f[B]yaf\f[R] how to assign an
applabel, what information elements to create when doing dpi, and how to assign
values to those elements.
.PP
An applabel rule has the form
.IP
.nf
\f[C]
 {label=<APP>,
  label_type=\[dq]<LABEL_TYPE>\[dq],
  value=[=[<EXPRESSION>]=],
  ports={<PORTS>},
  protocol=<PROTO>,
  active=<true|false>,
  <DPI-RELATED-ENTRIES>}
\f[R]
.fi
.PP
where
.IP \[bu] 2
At least \f[V]label\f[R], \f[V]label_type\f[R], and \f[V]value\f[R] keys are
required.
.IP \[bu] 2
<APP> is the application label to apply, and it is an unsigned 16-bit decimal
integer in the range 1 to 65535 inclusive.
This value must be unique across all rules.
.IP \[bu] 2
<LABEL_TYPE> is the type of rule, a string.
Three label_types of applabel rules are supported: \f[B]regex\f[R],
\f[B]plugin\f[R], and \f[B]signature\f[R].
(Additionally, type of \f[B]none\f[R] ignores the entry.)
These are described in more detail in the \[dq]Assigning...\[dq] sections below.
.IP \[bu] 2
<EXPRESSION> specifies how to recognize the given application protocol and is
dependent on the <label_type>.
It is a string.
.RS 2
.PP
When setting \f[V]value\f[R], we recommend using the syntax for a Lua \[dq]long
literal\[dq] so that any backslashes in the regular expression do not need to be
escaped.
A long literal is surrounded by a double square brackets called \[dq]long
brackets\[dq], and zero or more equal signs (\f[V]=\f[R]) may appear between
each set of brackets (the same number on each side),
\f[V][====[example]====]\f[R].
At least one equal sign is recommended when specifying a regex to disambiguate
from character ranges which also use square brackets.
.RE
.IP \[bu] 2
<PORTS> allows associating multiple ports to an applabel with \f[B]regex\f[R] or
\f[B]plugin\f[R] label_type.
If \[dq]ports\[dq] is not present, only the applabel is used to check for
matches against a flow\[aq]s source or destination ports.
<PORTS> MUST be defined as a comma-separated list of one or more integers in the
range 1 to 65535 inclusive, enclosed in curly braces.
<PORTS> MUST NOT include any applabel value or any other \[dq]ports\[dq] values
defined in other rules.
They must be non-overlapping.
Overall, this option helps \f[B]yaf\f[R] trigger applabel tests more efficiently
and improves applabel accuracy.
.IP \[bu] 2
<PROTO> limits a \f[B]regex\f[R] label_type to being tested only when the flow
record\[aq]s protocolIdentifier matches <PROTO> or when <PROTO> is 0.
If \[dq]protocol\[dq] is not present, the test is performed.
<PROTO> is a value between 0 and 255 inclusive, but only 0, 6, and 17 are
relevant since \f[B]yaf\f[R] only runs applabel checks for TCP and UDP records.
The protocol is ignored for \f[B]plugin\f[R] label_type rules; that check should
be performed by the plugin itself.
Specifying a protocol is best used to avoid false positives.
.IP \[bu] 2
The value of \f[V]active\f[R] is a boolean indicating whether the rule is
active, and defaults to true if not present.
.IP \[bu] 2
<DPI-RELATED-ENTRIES> are optional.
Here, this simply denotes where DPI-related rule entries would go, if
applicable.
.PP
Here is an example giving a complete definition of the \f[V]applabels\f[R]
variable.
.IP
.nf
\f[C]
applabels = {
  {label=80, label_type=\[dq]regex\[dq], value=[=[\[ha]HTTP/\[rs]d]=]}
}
\f[R]
.fi
.PP
In this case, any TCP or UDP flow record whose payload starts with
\[dq]HTTP/\[dq] followed by a digit is assigned the applabel 80, and all other
flows are assigned applabel 0.
.SS Assigning an Applabel Using Regular Expressions
.PP
A \[dq]regex\[dq] label_type rule has the following form:
.IP
.nf
\f[C]
 {label=<APP>,
  label_type=\[dq]regex\[dq],
  active=true,
  protocol=<PROTO>,
  value=[=[<PCRE_REGEX>]=],
  <DPI-RELATED-ENTRIES>}
\f[R]
.fi
.PP
The <PCRE_REGEX> is a PCRE (https://www.pcre.org/) regular expression (see the
PCRE documentation for details, particularly
pcrepattern (http://www.pcre.org/original/doc/html/pcrepattern.html) and
pcresyntax (http://www.pcre.org/original/doc/html/pcresyntax.html)).
\f[B]yaf\f[R] checks the available payload of both directions of the flow with
the <PCRE_REGEX>, and if the expression matches either direction of the payload
the label <APP> is applied to the flow.
.SS Assigning an Applabel Using A Plugin
.PP
Plugin rules are used to label application payload using a C dynamically loaded
library, and have the following form:
.IP
.nf
\f[C]
{label=\[rs]<APP\[rs]>,
 label_type=\[dq]plugin\[dq],
 active=true,
 value=[=[<LIBRARY>]=],
 args={[[ARG1]], [[ARG2]], ...},
 <DPI-RELATED-ENTRIES>}
\f[R]
.fi
.PP
where <LIBRARY> is the name of a dynamically loadable library that exists
somewhere within the LD_LIBRARY_PATH, the LTDL_LIBRARY_PATH, or a system library
path, without the library name extension (usually \f[V].so\f[R]).
If the plugin returns 1, the flow will be labeled with <APP>.
Otherwise, the flow will be labeled with the value the plugin returns (useful
for a plugin that can identify more than one protocol).
See the source code to the plugins that ship with \f[B]yaf\f[R] for details.
.PP
The \f[V]args\f[R] key is optional.
If present, its value is an array of strings that are to be passed as arguments
to the plugin.
.SS Assigning an Applabel Using a Signature
.PP
For regular expressions that are not tied to a particular port and when no DPI
is needed, use the signature rule.
These are processed before the regex and plugin type rules.
A signature type rule has this form:
.IP
.nf
\f[C]
{label=<N>,
 label_type=\[dq]signature\[dq],
 active=true,
 value=[=[<PCRE_REGEX>]=]}
\f[R]
.fi
.PP
The <PCRE_REGEX> is compared against the available payload of the flow; if the
expression matches, the label <N> is applied to the flow.
.SS Using the Proxy Plugin
.PP
If \f[B]yaf\f[R] is seeing traffic behind a web proxy, it may incorrectly label
https (443) traffic as http (80) due to the HTTP Connect method that occurs
before the Certificate exchange.
To accurately label https traffic, uncomment the following line in the
yafDPIRules.conf file at the top of the \f[V]applabels\f[R] variable:
.IP
.nf
\f[C]
{label=<N>, label_type=\[dq]plugin\[dq], value=[[proxyplugin]]},
\f[R]
.fi
.PP
and set <N> to the port on which the proxy is listening for connections.
This will not label https flows as <N>.
It will set the application label to 443 and will allow \f[B]yaf\f[R] DPI to
capture and export X.509 Certificates.
.PP
Note, if you enable the proxy plugin and <N> is also one of the ports
pre-defined in the HTTP rule, then remove that port from the \f[V]ports\f[R] key
in the HTTP rule.
.SS Tips and Caveats
.SS Match Order Logic
.PP
In order to determine the applabel, \f[B]yaf\f[R] goes through a particular
sequence of checks, which users should be aware of.
Ultimately, this sequence impacts application labeling accuracy, efficiency, and
how one constructs rules for protocols.
.PP
Rules must be active to be included in any checks.
For each flow that is passed to the applabel engine, checks are performed in the
following sequence:
.PP
Let DEFORD be the order of the rules as defined in the configuration file
.PP
Let PORT_MATCH be where \f[B]sourceTransportPort\f[R] or
\f[B]destinationTransportPort\f[R] = <APP> or any value defined in <PORTS>, if
present
.PP
Let PROTO_MATCH be where, if regex rule, \f[B]protocolIdentifier\f[R] = <PROTO>,
<PROTO> = 0, or <PROTO> is not present, or where, if plugin rule, the protocol
check passes in the plugin
.IP "1." 3
In DEFORD, compare each \f[B]signature\f[R] rule against the forward and/or
reverse payload
.IP "2." 3
Compare any \f[B]regex\f[R] or \f[B]plugin\f[R] rule where PORT_MATCH and
PROTO_MATCH against the \f[I]forward\f[R] payload
.IP "3." 3
In DEFORD, compare any \f[B]regex\f[R] or \f[B]plugin\f[R] rule against the
\f[I]forward\f[R] payload
.IP "4." 3
Compare any \f[B]regex\f[R] or \f[B]plugin\f[R] rule where PORT_MATCH and
PROTO_MATCH against the reverse payload
.IP "5." 3
In DEFORD, compare any \f[B]regex\f[R] or \f[B]plugin\f[R] rule against the
reverse payload
.IP "6." 3
No match or error, applabel 0 is applied to the flow
.PP
Once a match is found, the applabel engine will not continue to find a
\[dq]better\[dq] match - applabel processing stops on first match and applabel
<N> or <APP> is applied to the flow.
.PP
Given the above sequence, it is clear that the order of the rules as defined in
the configuration file matters.
.SS Accuracy
.PP
Generally around 80% of the traffic that \f[B]yaf\f[R] observes will not be
positively identified and will have an applabel value of 0.
This occurs for a number of reasons, including but not limited to the following:
.IP \[bu] 2
The vantage point of the sensor (e.g., running outside of firewalls or other
incoming packet filters), where the sensor is more likely to see half-open
connections, scanning and other \[dq]garbage\[dq] internet traffic
.IP \[bu] 2
Unknown, proprietary, malformed, or otherwise unsupported protocols
.IP \[bu] 2
Implementations do not always conform to protocol specs
.IP \[bu] 2
Overly specific or poorly written checks
.IP \[bu] 2
Protocol evolution and outdated checks
.SS Rule Tips
.IP \[bu] 2
More common protocols should have their rules inserted near the top of the
configuration file.
.IP \[bu] 2
Include all ports that are commonly associated with a given protocol (but which
do not overlap with other applabel and port definitions).
This increases the chances that the correct rule will be checked first.
.IP \[bu] 2
Include protocol checks.
If a given protocol only ever uses TCP, then a rule for that protocol does not
need to run against UDP flows.
This improves applabel accuracy and efficiency.
.IP \[bu] 2
Construct rule regular expressions that target the expected \f[I]forward\f[R]
payload for a given protocol, since the forward payload is checked prior to the
reverse payload.
Regular expressions specifically crafted for reverse payloads are not
recommended; unless there is no chance that they will match another protocol in
the list.
.IP \[bu] 2
Be aware of similarities between protocols and when those checks are performed.
.IP \[bu] 2
If possible, anchor regular expressions to the beginning of the payload (e.g.,
using \f[V]\[ha]\f[R]).
.SS Applabel and nDPI
.PP
The applabel engine and
nDPI (https://www.ntop.org/products/deep-packet-inspection/ndpi/), despite its
name, essentially attempt to do the same thing - identify the application
protocol in use within a flow.
While technically these features may be used together at the same time, nDPI is
generally meant to be an alternative to the applabel engine.
nDPI will typically be enabled in one of two ways:
.IP "1." 3
On its own (using \f[B]--ndpi\f[R]) if only application labeling is needed and
the user wants an alternative to the \f[B]yaf\f[R] applabel engine
.RS 4
.IP
.nf
\f[C]
yaf --daemonize --live pcap --in eth0              \[rs]
    --out localhost --ipfix-port=18000 --ipfix tcp \[rs]
    --ndpi --max-payload=384
\f[R]
.fi
.RE
.IP "2." 3
Each of applabel, DPI, and nDPI features will be enabled (using \f[B]--ndpi\f[R]
and \f[B]--dpi\f[R]) if an alternative application labeling is desired along
with DPI export.
However, \f[B]yaf\f[R] DPI requires the use of the applabel engine, so each of
these features will be on, albeit with a slight performance hit.
.RS 4
.IP
.nf
\f[C]
yaf --daemonize --live pcap --in eth0               \[rs]
    --out localhost --ipfix-port=18000 --ipfix tcp  \[rs]
    --ndpi --dpi --max-payload=4096
\f[R]
.fi
.RE
.PP
When nDPI is enabled, \f[B]yaf\f[R] exports the information elements
\f[B]ndpiL7Protocol\f[R] for the application protocol and
\f[B]ndpiL7SubProtocol\f[R] for the sub-protocol.
.SS Supported Protocols
.PP
The following application labels are included, in order, in the YAF 3.x
configuration file:
.PP
.TS
tab(@);
l r l l l.
T{
Protocol
T}@T{
Applabel
T}@T{
Type
T}@T{
Active
T}@T{
Notes
T}
_
T{
SSL/Proxied
T}@T{
user-defined
T}@T{
plugin
T}@T{
false
T}@T{
T}
T{
HTTP
T}@T{
80
T}@T{
regex
T}@T{
true
T}@T{
T}
T{
SSH
T}@T{
22
T}@T{
regex
T}@T{
true
T}@T{
T}
T{
SMTP
T}@T{
25
T}@T{
plugin
T}@T{
true
T}@T{
T}
T{
DNS
T}@T{
53
T}@T{
plugin
T}@T{
true
T}@T{
T}
T{
NETBIOS Name Service
T}@T{
137
T}@T{
plugin
T}@T{
true
T}@T{
1
T}
T{
FTP
T}@T{
21
T}@T{
regex
T}@T{
true
T}@T{
T}
T{
SSL/TLS
T}@T{
443
T}@T{
plugin
T}@T{
true
T}@T{
T}
T{
QUIC
T}@T{
51443
T}@T{
regex
T}@T{
true
T}@T{
T}
T{
SLP
T}@T{
427
T}@T{
plugin
T}@T{
true
T}@T{
T}
T{
SMB/NETBIOS Session Service
T}@T{
139
T}@T{
regex
T}@T{
true
T}@T{
T}
T{
IMAP
T}@T{
143
T}@T{
regex
T}@T{
true
T}@T{
T}
T{
IRC
T}@T{
194
T}@T{
plugin
T}@T{
true
T}@T{
T}
T{
RTSP
T}@T{
554
T}@T{
regex
T}@T{
true
T}@T{
T}
T{
SIP
T}@T{
5060
T}@T{
regex
T}@T{
true
T}@T{
T}
T{
RSYNC
T}@T{
873
T}@T{
regex
T}@T{
true
T}@T{
T}
T{
RDP
T}@T{
3389
T}@T{
regex
T}@T{
true
T}@T{
T}
T{
IKE
T}@T{
500
T}@T{
regex
T}@T{
true
T}@T{
T}
T{
PPTP
T}@T{
1723
T}@T{
plugin
T}@T{
true
T}@T{
T}
T{
NNTP
T}@T{
119
T}@T{
plugin
T}@T{
true
T}@T{
T}
T{
TFTP
T}@T{
69
T}@T{
plugin
T}@T{
true
T}@T{
T}
T{
Teredo
T}@T{
3544
T}@T{
plugin
T}@T{
true
T}@T{
T}
T{
MYSQL
T}@T{
3306
T}@T{
plugin
T}@T{
true
T}@T{
T}
T{
POP3
T}@T{
110
T}@T{
plugin
T}@T{
true
T}@T{
T}
T{
SNMP
T}@T{
161
T}@T{
plugin
T}@T{
true
T}@T{
T}
T{
MQTT
T}@T{
1883
T}@T{
regex
T}@T{
true
T}@T{
T}
T{
AIM
T}@T{
5190
T}@T{
plugin
T}@T{
true
T}@T{
T}
T{
Gnutella P2P
T}@T{
6346
T}@T{
regex
T}@T{
true
T}@T{
T}
T{
Yahoo Messenger
T}@T{
5050
T}@T{
regex
T}@T{
true
T}@T{
T}
T{
SOCKS
T}@T{
1080
T}@T{
plugin
T}@T{
true
T}@T{
T}
T{
BGP
T}@T{
179
T}@T{
plugin
T}@T{
true
T}@T{
T}
T{
DHCP/BOOTP
T}@T{
67
T}@T{
plugin
T}@T{
true
T}@T{
T}
T{
VNC/RFB
T}@T{
5900
T}@T{
regex
T}@T{
true
T}@T{
T}
T{
RTP
T}@T{
5004
T}@T{
plugin
T}@T{
true
T}@T{
T}
T{
RTCP
T}@T{
5005
T}@T{
plugin
T}@T{
true
T}@T{
2
T}
T{
Jabber XMPP
T}@T{
5222
T}@T{
regex
T}@T{
true
T}@T{
T}
T{
MSNP
T}@T{
1863
T}@T{
regex
T}@T{
true
T}@T{
T}
T{
MSOffice Update
T}@T{
2223
T}@T{
regex
T}@T{
true
T}@T{
T}
T{
MGCP
T}@T{
2427
T}@T{
regex
T}@T{
true
T}@T{
T}
T{
MEGACO
T}@T{
2944
T}@T{
regex
T}@T{
true
T}@T{
T}
T{
VMware Server Console
T}@T{
902
T}@T{
regex
T}@T{
true
T}@T{
T}
T{
BitTorrent
T}@T{
6881
T}@T{
regex
T}@T{
true
T}@T{
T}
T{
LDAP
T}@T{
389
T}@T{
plugin
T}@T{
true
T}@T{
T}
T{
DNP3
T}@T{
20000
T}@T{
plugin
T}@T{
true
T}@T{
T}
T{
MODBUS
T}@T{
502
T}@T{
plugin
T}@T{
true
T}@T{
T}
T{
Ethernet/IP
T}@T{
44818
T}@T{
plugin
T}@T{
true
T}@T{
T}
T{
NETBIOS Datagram Service
T}@T{
138
T}@T{
plugin
T}@T{
true
T}@T{
T}
T{
Gh0st RAT
T}@T{
9997
T}@T{
plugin
T}@T{
true
T}@T{
T}
T{
Poison Ivy
T}@T{
65534
T}@T{
plugin
T}@T{
true
T}@T{
T}
T{
LDP
T}@T{
646
T}@T{
plugin
T}@T{
true
T}@T{
T}
T{
Palevo
T}@T{
65533
T}@T{
plugin
T}@T{
true
T}@T{
T}
T{
NTP
T}@T{
123
T}@T{
plugin
T}@T{
true
T}@T{
T}
.TE
.PP
Notes:
.IP "1." 3
NETBIOS Name Service is not included in the configuration file.
It is contained in the DNS plugin due to similarities in the protocols.
.IP "2." 3
RTCP is not included in the configuration file.
It is contained in the RTP plugin due to similarities in the protocols.
.SH FILES
.TP
??sysconfdir??/yafDPIRules.conf
Default location of the Application Labeling/Deep Packet Inspection rules file.
.TP
??pkglibdir??
Directory from which \f[B]yaf\f[R] loads Application Labeling/Deep Packet
Inspection plug-ins.
.SH SEE ALSO
.PP
\f[B]yaf(1)\f[R], \f[B]yafdpi(1)\f[R], \f[B]pcresyntax(3)\f[R],
\f[B]pcrepattern(3)\f[R], https://www.lua.org/, https://www.pcre.org/
